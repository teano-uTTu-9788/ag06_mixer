#!/usr/bin/env bash
#
# Dev CLI - Modular Terminal Automation Framework
# Based on research of Google, Meta, Netflix best practices
#
set -euo pipefail

# Framework root directory
readonly FRAMEWORK_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly FRAMEWORK_LIB="${FRAMEWORK_ROOT}/lib"
readonly FRAMEWORK_CONFIG_PATH="${FRAMEWORK_ROOT}/config"

# Version information
readonly FRAMEWORK_VERSION="1.0.0"
readonly FRAMEWORK_NAME="Terminal Automation Framework"

# Load core framework
source "${FRAMEWORK_LIB}/core/bootstrap.sh"
source "${FRAMEWORK_LIB}/core/logger.sh"
source "${FRAMEWORK_LIB}/core/config.sh"
source "${FRAMEWORK_LIB}/utils/validation.sh"

# Load MCP integration
source "${FRAMEWORK_LIB}/mcp/mcp_server.sh"
source "${FRAMEWORK_LIB}/mcp/mcp_client.sh"
source "${FRAMEWORK_LIB}/mcp/mcp_tools.sh"

# Load enterprise integrations
source "${FRAMEWORK_LIB}/observability/sre_observability.sh"
source "${FRAMEWORK_LIB}/cicd/azure_devops.sh"
source "${FRAMEWORK_LIB}/build/meta_build_system.sh"
source "${FRAMEWORK_LIB}/resilience/netflix_chaos.sh"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Main CLI function
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        setup)
            dev::setup "$@"
            ;;
        test)
            dev::test "$@"
            ;;
        build)
            dev::build "$@"
            ;;
        deploy)
            dev::deploy "$@"
            ;;
        lint)
            dev::lint "$@"
            ;;
        format|fmt)
            dev::format "$@"
            ;;
        doctor)
            dev::doctor "$@"
            ;;
        clean)
            dev::clean "$@"
            ;;
        bootstrap)
            dev::bootstrap "$@"
            ;;
        ci)
            dev::ci "$@"
            ;;
        mcp)
            dev::mcp "$@"
            ;;
        sre)
            dev::sre "$@"
            ;;
        azure)
            dev::azure "$@"
            ;;
        meta)
            dev::meta "$@"
            ;;
        netflix)
            dev::netflix "$@"
            ;;
        version|--version|-v)
            dev::version
            ;;
        help|--help|-h)
            dev::help
            ;;
        *)
            log::error "Unknown command: $command"
            dev::help
            exit 1
            ;;
    esac
}

# Development environment setup
dev::setup() {
    log::info "Setting up development environment..."
    
    # Check prerequisites
    dev::doctor --quiet
    
    # Install Homebrew dependencies
    if command -v brew >/dev/null 2>&1; then
        log::info "Installing Homebrew dependencies..."
        brew bundle --file="${FRAMEWORK_ROOT}/Brewfile" --no-upgrade
    else
        log::warning "Homebrew not found. Please install Homebrew first."
    fi
    
    # Setup Git hooks
    if [[ -d .git ]]; then
        log::info "Installing Git hooks..."
        cp "${FRAMEWORK_ROOT}/hooks/"* .git/hooks/
        chmod +x .git/hooks/*
    fi
    
    log::success "Development environment setup complete!"
}

# Run tests
dev::test() {
    local test_type="${1:-all}"
    
    log::info "Running tests: $test_type"
    
    case "$test_type" in
        unit)
            bats test/unit/*.bats
            ;;
        integration)
            bats test/integration/*.bats
            ;;
        all)
            bats test/**/*.bats
            ;;
        *)
            log::error "Unknown test type: $test_type"
            exit 1
            ;;
    esac
}

# Build distributables
dev::build() {
    log::info "Building framework distributables..."
    
    local build_dir="${FRAMEWORK_ROOT}/build"
    mkdir -p "$build_dir"
    
    # Create distribution archive
    tar -czf "${build_dir}/terminal-automation-framework-${FRAMEWORK_VERSION}.tar.gz" \
        --exclude='.git*' \
        --exclude='build' \
        --exclude='test' \
        .
    
    # Create Homebrew formula
    dev::_generate_homebrew_formula
    
    log::success "Build complete! Check build/ directory"
}

# Deploy to package managers
dev::deploy() {
    local target="${1:-homebrew}"
    
    case "$target" in
        homebrew)
            dev::_deploy_homebrew
            ;;
        github)
            dev::_deploy_github
            ;;
        *)
            log::error "Unknown deployment target: $target"
            exit 1
            ;;
    esac
}

# Lint shell scripts
dev::lint() {
    log::info "Linting shell scripts..."
    
    # Use shellcheck for static analysis
    find . -name "*.sh" -not -path "./build/*" | xargs shellcheck
    
    # Use shfmt for formatting check
    find . -name "*.sh" -not -path "./build/*" | xargs shfmt -d
    
    log::success "Linting complete!"
}

# Format shell scripts
dev::format() {
    log::info "Formatting shell scripts..."
    
    # Use shfmt to format
    find . -name "*.sh" -not -path "./build/*" | xargs shfmt -w -i 4 -ci
    
    log::success "Formatting complete!"
}

# System health check
dev::doctor() {
    local quiet="${1:-}"
    
    [[ "$quiet" != "--quiet" ]] && log::info "Running system diagnostics..."
    
    local issues=0
    
    # Check required tools
    local required_tools=(bash git curl jq)
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log::error "Required tool missing: $tool"
            ((issues++))
        fi
    done
    
    # Check optional tools
    local optional_tools=(brew shellcheck shfmt bats)
    for tool in "${optional_tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            [[ "$quiet" != "--quiet" ]] && log::warning "Optional tool missing: $tool"
        fi
    done
    
    # Check framework integrity
    local required_dirs=(lib config test)
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log::error "Required directory missing: $dir"
            ((issues++))
        fi
    done
    
    if [[ $issues -eq 0 ]]; then
        [[ "$quiet" != "--quiet" ]] && log::success "All systems operational!"
        return 0
    else
        log::error "Found $issues issues. Run 'dev setup' to fix."
        return 1
    fi
}

# Clean build artifacts
dev::clean() {
    log::info "Cleaning build artifacts..."
    
    rm -rf build/
    rm -rf .coverage/
    find . -name "*.log" -delete
    
    log::success "Clean complete!"
}

# Bootstrap new project
dev::bootstrap() {
    local project_name="${1:-my-project}"
    
    log::info "Bootstrapping new project: $project_name"
    
    mkdir -p "$project_name"/{lib/core,lib/utils,lib/modules,config,test,docs}
    
    # Copy framework templates
    cp "${FRAMEWORK_ROOT}/templates/project/"* "$project_name/"
    
    log::success "Project $project_name bootstrapped!"
}

# CI/CD operations
dev::ci() {
    local operation="${1:-validate}"
    
    case "$operation" in
        validate)
            dev::doctor --quiet
            dev::lint
            dev::test all
            ;;
        build)
            dev::build
            ;;
        deploy)
            dev::deploy github
            ;;
        *)
            log::error "Unknown CI operation: $operation"
            exit 1
            ;;
    esac
}

# MCP operations
dev::mcp() {
    local operation="${1:-help}"
    shift || true
    
    case "$operation" in
        server)
            local action="${1:-start}"
            case "$action" in
                start)
                    log::info "Starting MCP server..."
                    mcp::server::start "$@"
                    ;;
                stop)
                    log::info "Stopping MCP server..."
                    mcp::server::stop
                    ;;
                status)
                    mcp::server::status
                    ;;
                logs)
                    mcp::server::logs
                    ;;
                *)
                    echo "Usage: dev mcp server {start|stop|status|logs}"
                    exit 1
                    ;;
            esac
            ;;
        client)
            local server_url="${1:-http://localhost:3333}"
            shift || true
            local client_command="${1:-interactive}"
            
            case "$client_command" in
                connect)
                    mcp::client::connect "$server_url"
                    ;;
                tools)
                    mcp::client::connect "$server_url"
                    mcp::client::list_tools
                    ;;
                call)
                    if [[ $# -lt 2 ]]; then
                        log::error "Usage: dev mcp client <url> call <tool> [args]"
                        exit 1
                    fi
                    local tool_name="$2"
                    local tool_args="${3:-{}}"
                    mcp::client::connect "$server_url"
                    mcp::client::call_tool "$tool_name" "$tool_args"
                    ;;
                resources)
                    mcp::client::connect "$server_url"
                    mcp::client::list_resources
                    ;;
                interactive)
                    mcp::client::connect "$server_url"
                    mcp::client::interactive
                    ;;
                *)
                    echo "Usage: dev mcp client <url> {connect|tools|call|resources|interactive}"
                    exit 1
                    ;;
            esac
            ;;
        tools)
            local tool_action="${1:-list}"
            shift || true
            
            case "$tool_action" in
                list)
                    mcp::tools::list
                    ;;
                register)
                    if [[ $# -lt 4 ]]; then
                        log::error "Usage: dev mcp tools register <name> <description> <schema> <handler>"
                        exit 1
                    fi
                    mcp::tools::register "$1" "$2" "$3" "$4"
                    ;;
                unregister)
                    if [[ $# -lt 1 ]]; then
                        log::error "Usage: dev mcp tools unregister <name>"
                        exit 1
                    fi
                    mcp::tools::unregister "$1"
                    ;;
                test)
                    if [[ $# -lt 1 ]]; then
                        log::error "Usage: dev mcp tools test <name> [args]"
                        exit 1
                    fi
                    mcp::tools::test "$1" "${2:-{}}"
                    ;;
                *)
                    echo "Usage: dev mcp tools {list|register|unregister|test}"
                    exit 1
                    ;;
            esac
            ;;
        help|*)
            cat << EOF
${BLUE}Model Context Protocol (MCP) Integration${NC}

${YELLOW}Usage:${NC}
  dev mcp <command> [options]

${YELLOW}Server Commands:${NC}
  ${GREEN}server start [port]${NC}     Start MCP server (default: 3333)
  ${GREEN}server stop${NC}             Stop MCP server
  ${GREEN}server status${NC}           Check server status
  ${GREEN}server logs${NC}             Show server logs

${YELLOW}Client Commands:${NC}
  ${GREEN}client [url] connect${NC}     Connect to MCP server
  ${GREEN}client [url] tools${NC}       List available tools
  ${GREEN}client [url] call <tool> [args]${NC}  Call a tool
  ${GREEN}client [url] resources${NC}   List available resources
  ${GREEN}client [url] interactive${NC} Start interactive session

${YELLOW}Tool Management:${NC}
  ${GREEN}tools list${NC}               List registered tools
  ${GREEN}tools register <name> <desc> <schema> <handler>${NC}  Register new tool
  ${GREEN}tools unregister <name>${NC}  Unregister tool
  ${GREEN}tools test <name> [args]${NC} Test tool execution

${YELLOW}Examples:${NC}
  dev mcp server start 8080          # Start server on port 8080
  dev mcp client interactive         # Interactive client session
  dev mcp client tools               # List tools on default server
  dev mcp client call run_command '{"command": "ls -la"}'
  dev mcp tools list                 # Show registered tools

${YELLOW}MCP Specification:${NC}
  Protocol Version: 2024-11-05 (2025-06-18 OAuth extensions)
  Transport: HTTP + Server-Sent Events (SSE)
  Security: OAuth 2.0 Resource Server with Resource Indicators
  
EOF
            ;;
    esac
}

# SRE Observability wrapper
dev::sre() {
    sre::observability::main "$@"
}

# Azure DevOps wrapper
dev::azure() {
    azure::devops::main "$@"
}

# Meta Build System wrapper
dev::meta() {
    meta::build::main "$@"
}

# Netflix Chaos Engineering wrapper
dev::netflix() {
    netflix::chaos::main "$@"
}

# Show version
dev::version() {
    echo "$FRAMEWORK_NAME v$FRAMEWORK_VERSION"
}

# Show help
dev::help() {
    cat << EOF
${BLUE}$FRAMEWORK_NAME${NC} v$FRAMEWORK_VERSION

${YELLOW}Usage:${NC}
  dev <command> [options]

${YELLOW}Commands:${NC}
  ${GREEN}setup${NC}       Setup development environment
  ${GREEN}test${NC}        Run tests (unit|integration|all)
  ${GREEN}build${NC}       Build distributables
  ${GREEN}deploy${NC}      Deploy to package managers
  ${GREEN}lint${NC}        Lint shell scripts
  ${GREEN}format${NC}      Format shell scripts
  ${GREEN}doctor${NC}      Check system health
  ${GREEN}clean${NC}       Clean build artifacts
  ${GREEN}bootstrap${NC}   Create new project
  ${GREEN}ci${NC}          CI/CD operations
  ${GREEN}mcp${NC}         Model Context Protocol operations
  ${GREEN}sre${NC}         Google SRE observability and monitoring
  ${GREEN}azure${NC}       Microsoft Azure DevOps CI/CD integration
  ${GREEN}meta${NC}        Meta Buck2-inspired build system
  ${GREEN}netflix${NC}     Netflix chaos engineering and resilience
  ${GREEN}version${NC}     Show version
  ${GREEN}help${NC}        Show this help

${YELLOW}Examples:${NC}
  dev setup                    # Setup development environment
  dev test unit               # Run unit tests
  dev build                   # Build framework
  dev bootstrap my-cli        # Create new CLI project
  dev ci validate             # Run CI validation
  dev mcp server start        # Start MCP server
  dev mcp client interactive  # Interactive MCP session
  dev sre observability init  # Initialize SRE monitoring
  dev azure devops auth       # Authenticate with Azure DevOps
  dev meta build init         # Initialize Meta build system
  dev netflix chaos init      # Initialize chaos engineering

${YELLOW}Documentation:${NC}
  https://github.com/your-org/terminal-automation-framework

EOF
}

# Private functions

dev::_generate_homebrew_formula() {
    local formula_file="${FRAMEWORK_ROOT}/build/terminal-automation-framework.rb"
    
    cat > "$formula_file" << EOF
class TerminalAutomationFramework < Formula
  desc "Modular terminal automation framework for macOS"
  homepage "https://github.com/your-org/terminal-automation-framework"
  url "https://github.com/your-org/terminal-automation-framework/archive/v${FRAMEWORK_VERSION}.tar.gz"
  version "${FRAMEWORK_VERSION}"
  sha256 "$(shasum -a 256 "${FRAMEWORK_ROOT}/build/terminal-automation-framework-${FRAMEWORK_VERSION}.tar.gz" | cut -d' ' -f1)"

  depends_on "bash"
  depends_on "jq"
  depends_on "shellcheck"
  depends_on "shfmt"

  def install
    bin.install "dev"
    lib.install Dir["lib/*"]
    etc.install Dir["config/*"]
  end

  test do
    system "#{bin}/dev", "version"
  end
end
EOF
    
    log::info "Generated Homebrew formula: $formula_file"
}

dev::_deploy_homebrew() {
    log::info "Deploying to Homebrew..."
    # Implementation for Homebrew tap deployment
    log::warning "Homebrew deployment not yet implemented"
}

dev::_deploy_github() {
    log::info "Deploying to GitHub..."
    # Implementation for GitHub releases
    log::warning "GitHub deployment not yet implemented"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi