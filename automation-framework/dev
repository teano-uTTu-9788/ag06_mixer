#!/usr/bin/env bash
# Dev CLI - Terminal automation framework following Google/Meta best practices
# Provides: Unified developer interface for CI/CD operations
# Used by: Development workflows, CI/CD pipelines, automated deployments

set -euo pipefail  # Google recommended: Exit on error, undefined vars, pipe failures

# Find the framework root directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRAMEWORK_ROOT="${SCRIPT_DIR}"
LIB_DIR="${FRAMEWORK_ROOT}/scripts/lib"

# Validate lib directory exists
if [[ ! -d "$LIB_DIR" ]]; then
    echo "ERROR: Missing scripts/lib directory at: $LIB_DIR" >&2
    exit 1
fi

# Source all libraries (Google Shell Style Guide - explicit sourcing)
# shellcheck source=./scripts/lib/core.sh
source "$LIB_DIR/core.sh"
# shellcheck source=./scripts/lib/homebrew.sh
source "$LIB_DIR/homebrew.sh"
# shellcheck source=./scripts/lib/git.sh
source "$LIB_DIR/git.sh"

# Initialize error handling
setup_error_handling "dev"

# Version
readonly VERSION="2.0.0"

usage() {
  cat <<USAGE
${BLUE}dev${NC} — Terminal Automation Framework v${VERSION}
${PURPLE}Following Google/Meta best practices for CI/CD and developer productivity${NC}

${WHITE}USAGE:${NC} dev <command> [options]

${WHITE}COMMANDS:${NC}
  ${GREEN}doctor${NC}          Check system health (Homebrew, Git, tools)
  ${GREEN}bootstrap${NC}       Bootstrap development environment
  ${GREEN}install${NC} <pkg>   Install package via Homebrew with validation
  ${GREEN}update${NC}          Update Homebrew and all packages
  ${GREEN}cleanup${NC}         Clean up Homebrew cache and outdated packages
  ${GREEN}git:setup${NC}       Configure Git with recommended settings
  ${GREEN}git:branch${NC} <n>  Create and switch to new branch
  ${GREEN}lint${NC}            Run ShellCheck on all scripts
  ${GREEN}format${NC}          Format shell scripts with shfmt
  ${GREEN}test${NC}            Run BATS test suite (if available)
  ${GREEN}ci${NC}              Run full CI pipeline locally
  ${GREEN}parallel:init${NC}   Initialize parallel workflow environment
  ${GREEN}parallel:register${NC} Register Claude instance for parallel work
  ${GREEN}parallel:status${NC} Show parallel workflow status
  ${GREEN}parallel:create-tasks${NC} Create AiOke improvement tasks
  ${GREEN}parallel:distribute${NC} Distribute tasks to active instances
  ${GREEN}parallel:monitor${NC} Monitor parallel workflow progress
  ${GREEN}version${NC}         Show version information
  ${GREEN}help${NC}            Show this help message

${WHITE}ENVIRONMENT VARIABLES:${NC}
  LOG_LEVEL       Set to 'DEBUG' for verbose logging
  PROJECT_ROOT    Override project root directory
  CI              Set to 'true' for CI environment behavior
  
${WHITE}EXAMPLES:${NC}
  dev doctor                    # Check system health
  dev bootstrap                 # Set up development environment
  dev install shellcheck        # Install shellcheck via Homebrew
  dev git:setup "Name" "email"  # Configure Git user
  dev git:branch feature/new    # Create feature branch
  dev ci                        # Run full CI pipeline

${WHITE}FRAMEWORK STRUCTURE:${NC}
  Framework root: ${FRAMEWORK_ROOT}
  Libraries: ${LIB_DIR}
  Logs: ${LOG_FILE}

${CYAN}For more information, see: https://github.com/your-org/automation-framework${NC}
USAGE
}

cmd_doctor() {
  log_info "Running system health check (Google SRE-style diagnostics)..."
  
  # System information
  log_info "Operating System: $(get_os)"
  log_info "Architecture: $(get_arch)"
  log_info "Shell: ${SHELL}"
  
  if is_macos; then
    log_info "macOS Version: $(sw_vers -productVersion 2>/dev/null || echo 'Unknown')"
  fi
  
  if is_ci; then
    log_info "Environment: CI/CD Pipeline"
  else
    log_info "Environment: Local Development"
  fi
  
  # Git repository validation
  git_validate_repo || log_warn "Not in a Git repository"
  
  # Check critical tools (required for framework operation)
  log_info "Checking critical tools..."
  local critical_tools=("git" "curl" "bash")
  local missing_critical=0
  
  for tool in "${critical_tools[@]}"; do
    if validate_command "${tool}" false; then
      log_ok "✓ ${tool}"
    else
      log_error "✗ ${tool} (CRITICAL)"
      ((missing_critical++))
    fi
  done
  
  # Check recommended tools (Meta-style developer experience)
  log_info "Checking recommended tools..."
  local recommended_tools=("brew" "jq" "shellcheck" "shfmt" "gh")
  local missing_recommended=0
  
  for tool in "${recommended_tools[@]}"; do
    if validate_command "${tool}" false; then
      log_ok "✓ ${tool}"
    else
      log_warn "○ ${tool} (recommended)"
      ((missing_recommended++))
    fi
  done
  
  # Homebrew health check
  if command -v brew >/dev/null 2>&1; then
    log_info "Running Homebrew diagnostics..."
    if brew_doctor; then
      log_ok "Homebrew is healthy"
    else
      log_warn "Homebrew has some issues (non-critical)"
    fi
    
    # Display Homebrew system info
    brew_info_system
  else
    log_warn "Homebrew not installed - run 'dev bootstrap' to install"
  fi
  
  # Summary and recommendations
  if [[ ${missing_critical} -eq 0 ]]; then
    log_ok "✅ System health check PASSED"
    if [[ ${missing_recommended} -gt 0 ]]; then
      log_info "💡 Consider running 'dev bootstrap' to install recommended tools"
    fi
  else
    log_fatal "❌ System health check FAILED - Missing ${missing_critical} critical tool(s)"
  fi
}

cmd_bootstrap() {
  log_info "Bootstrapping development environment (following Google/Meta practices)..."
  
  # Install Homebrew if needed (Meta-style dependency management)
  if ! command -v brew >/dev/null 2>&1; then
    if is_macos; then
      log_info "Installing Homebrew..."
      install_homebrew
    else
      log_warn "Skipping Homebrew installation (not on macOS)"
      return 1
    fi
  else
    log_info "Homebrew already installed"
  fi
  
  # Update Homebrew to latest version
  brew_update
  
  # Install essential development tools
  log_info "Installing essential development tools..."
  local essential_tools=("jq" "shellcheck" "shfmt" "gh")
  
  brew_install "${essential_tools[@]}"
  
  # Install optional tools for enhanced developer experience
  log_info "Installing optional development tools..."
  local optional_tools=("bat" "fd" "ripgrep" "fzf")
  
  # Install optional tools but don't fail if they're not available
  for tool in "${optional_tools[@]}"; do
    brew_install "${tool}" || log_warn "Could not install optional tool: ${tool}"
  done
  
  # Set up Git with recommended defaults (Google-style)
  if command -v git >/dev/null 2>&1; then
    log_info "Configuring Git with recommended defaults..."
    git_setup_defaults false  # Local configuration
    log_ok "Git configured with recommended settings"
  fi
  
  # Create Brewfile if it doesn't exist
  local brewfile="${FRAMEWORK_ROOT}/Brewfile"
  if [[ ! -f "${brewfile}" ]]; then
    log_info "Creating Brewfile for dependency management..."
    cat > "${brewfile}" <<'EOF'
# Development tools Brewfile
# Install with: brew bundle

# Essential tools
brew "git"
brew "curl" 
brew "jq"

# Shell tools
brew "shellcheck"
brew "shfmt"

# GitHub CLI
brew "gh"

# Enhanced developer experience
brew "bat"         # Better cat with syntax highlighting
brew "fd"          # Better find
brew "ripgrep"     # Better grep
brew "fzf"         # Fuzzy finder

# Optional GUI applications
# cask "visual-studio-code"
# cask "iterm2"
EOF
    log_ok "Brewfile created at: ${brewfile}"
  fi
  
  log_ok "🎉 Bootstrap complete! Run 'dev doctor' to verify installation"
}

# Package installation command (Google-style)
cmd_install() {
  local package="${1:-}"
  
  if [[ -z "${package}" ]]; then
    log_error "Package name required"
    log_info "Usage: dev install <package>"
    return 1
  fi
  
  if ! command -v brew >/dev/null 2>&1; then
    log_fatal "Homebrew not installed. Run 'dev bootstrap' first."
  fi
  
  log_info "Installing package: ${package}"
  brew_install "${package}"
}

# Update all packages (Meta-style maintenance)
cmd_update() {
  log_info "Updating Homebrew and all packages..."
  
  if ! command -v brew >/dev/null 2>&1; then
    log_fatal "Homebrew not installed. Run 'dev bootstrap' first."
  fi
  
  brew_update
  brew_upgrade
  log_ok "All packages updated successfully"
}

# Cleanup command (Google SRE-style maintenance)
cmd_cleanup() {
  log_info "Cleaning up Homebrew cache and outdated packages..."
  
  if ! command -v brew >/dev/null 2>&1; then
    log_fatal "Homebrew not installed. Run 'dev bootstrap' first."
  fi
  
  brew_cleanup
  log_ok "Cleanup completed"
}

# Git setup command
cmd_git_setup() {
  local name="${1:-}"
  local email="${2:-}"
  local global="${3:-false}"
  
  if [[ -z "${name}" ]] || [[ -z "${email}" ]]; then
    log_error "Both name and email are required"
    log_info "Usage: dev git:setup \"Your Name\" \"your.email@example.com\" [global]"
    return 1
  fi
  
  log_info "Setting up Git configuration..."
  git_setup_user "${name}" "${email}" "${global}"
  git_setup_defaults "${global}"
  log_ok "Git configuration completed"
}

# Git branch creation command
cmd_git_branch() {
  local branch_name="${1:-}"
  local base_branch="${2:-main}"
  
  if [[ -z "${branch_name}" ]]; then
    log_error "Branch name is required"
    log_info "Usage: dev git:branch <branch-name> [base-branch]"
    return 1
  fi
  
  git_create_branch "${branch_name}" "${base_branch}"
}

# Format shell scripts (Google Shell Style Guide)
cmd_format() {
  log_info "Formatting shell scripts (Google Shell Style Guide)..."
  
  if ! command -v shfmt >/dev/null 2>&1; then
    log_warn "shfmt not installed. Run 'dev bootstrap' to install it."
    return 1
  fi
  
  # Format all shell scripts with Google-recommended settings
  timer_start
  find "${FRAMEWORK_ROOT}" -name "*.sh" -type f -exec shfmt -w -i 2 -ci {} \;
  shfmt -w -i 2 -ci "${FRAMEWORK_ROOT}/dev" 2>/dev/null || true
  timer_end
  
  log_ok "Shell script formatting completed"
}

# Lint shell scripts (Google Shell Style Guide compliance)
cmd_lint() {
  log_info "Running ShellCheck linter (Google Shell Style Guide compliance)..."
  
  if ! command -v shellcheck >/dev/null 2>&1; then
    log_warn "ShellCheck not installed. Run 'dev bootstrap' to install it."
    return 1
  fi
  
  local lint_errors=0
  timer_start
  
  # Lint all shell scripts in the framework
  log_info "Linting framework scripts..."
  while IFS= read -r -d '' file; do
    log_debug "Linting: ${file}"
    if ! shellcheck "${file}"; then
      ((lint_errors++))
    fi
  done < <(find "${FRAMEWORK_ROOT}" -name "*.sh" -type f -print0)
  
  # Lint the main dev script
  if ! shellcheck "${FRAMEWORK_ROOT}/dev"; then
    ((lint_errors++))
  fi
  
  timer_end
  
  if [[ ${lint_errors} -eq 0 ]]; then
    log_ok "All shell scripts passed linting"
  else
    log_error "Found ${lint_errors} linting error(s)"
    return 1
  fi
}

# Test command (BATS framework)
cmd_test() {
  log_info "Running test suite..."
  
  # Run BATS tests if available
  if [[ -d "${FRAMEWORK_ROOT}/tests" ]] && command -v bats >/dev/null 2>&1; then
    log_info "Running BATS test suite..."
    timer_start
    bats "${FRAMEWORK_ROOT}/tests"/*.bats
    timer_end
    log_ok "All tests passed"
  else
    if [[ ! -d "${FRAMEWORK_ROOT}/tests" ]]; then
      log_warn "No test directory found at: ${FRAMEWORK_ROOT}/tests"
    fi
    if ! command -v bats >/dev/null 2>&1; then
      log_warn "BATS not installed. Install with: brew install bats-core"
    fi
    log_info "Skipping tests"
  fi
}

# CI pipeline (Google/Meta-style local CI)
cmd_ci() {
  log_info "Running full CI pipeline locally (Google/Meta-style)..."
  
  local ci_start_time
  ci_start_time=$(date +%s)
  
  # Step 1: Environment check
  log_info "🔍 Step 1: Environment validation"
  cmd_doctor || return 1
  
  # Step 2: Code formatting check
  log_info "📝 Step 2: Code formatting validation"
  if command -v shfmt >/dev/null 2>&1; then
    # Check if code is properly formatted (don't modify)
    if ! find "${FRAMEWORK_ROOT}" -name "*.sh" -type f -exec shfmt -d -i 2 -ci {} \;; then
      log_error "Code formatting issues found. Run 'dev format' to fix."
      return 1
    fi
    log_ok "Code formatting validated"
  fi
  
  # Step 3: Linting
  log_info "🔍 Step 3: Code linting"
  cmd_lint || return 1
  
  # Step 4: Testing
  log_info "🧪 Step 4: Test execution"
  cmd_test || return 1
  
  # Step 5: Git status check (ensure clean working directory)
  log_info "🔄 Step 5: Git status validation"
  if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
    if ! git diff --quiet; then
      log_warn "Working directory has uncommitted changes"
    else
      log_ok "Working directory is clean"
    fi
  fi
  
  local ci_end_time
  ci_end_time=$(date +%s)
  local ci_duration=$((ci_end_time - ci_start_time))
  
  log_ok "✅ CI pipeline completed successfully in ${ci_duration}s"
}


main() {
  local cmd="${1:-help}"
  shift || true
  
  case "$cmd" in
    doctor)
      cmd_doctor "$@"
      ;;
    bootstrap)
      cmd_bootstrap "$@"
      ;;
    install)
      cmd_install "$@"
      ;;
    update)
      cmd_update "$@"
      ;;
    cleanup)
      cmd_cleanup "$@"
      ;;
    git:setup)
      cmd_git_setup "$@"
      ;;
    git:branch)
      cmd_git_branch "$@"
      ;;
    format|fmt)
      cmd_format "$@"
      ;;
    lint)
      cmd_lint "$@"
      ;;
    test)
      cmd_test "$@"
      ;;
    ci)
      cmd_ci "$@"
      ;;
    parallel:init)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" init
      ;;
    parallel:register)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" register "$@"
      ;;
    parallel:status)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" status
      ;;
    parallel:create-tasks)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" create-aioke-tasks
      ;;
    parallel:distribute)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" distribute
      ;;
    parallel:monitor)
      "${FRAMEWORK_ROOT}/parallel_workflow_orchestrator.sh" monitor "${2:-}"
      ;;
    help|-h|--help)
      usage
      ;;
    version|--version)
      echo "dev version ${VERSION}"
      ;;
    *)
      log_error "Unknown command: $cmd"
      echo ""
      log_info "Available commands:"
      log_info "  doctor, bootstrap, install, update, cleanup"
      log_info "  git:setup, git:branch, format, lint, test, ci"
      log_info "  parallel:init, parallel:register, parallel:status"
      log_info "  parallel:create-tasks, parallel:distribute, parallel:monitor"
      log_info "  help, version"
      echo ""
      log_info "Run 'dev help' for detailed usage information"
      return 2
      ;;
  esac
}

# Run main function
main "$@"