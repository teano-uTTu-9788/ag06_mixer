name: Automation Framework CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'automation-framework/**'
      - '.github/workflows/automation-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'automation-framework/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

env:
  FRAMEWORK_VERSION: '1.0.0'
  METRICS_ENABLED: 'true'
  PARALLEL_WORKERS: 4

jobs:
  # Stage 1: Build and Validate
  validate:
    name: Validate Framework
    runs-on: ubuntu-latest
    outputs:
      validation_status: ${{ steps.validate.outputs.status }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup environment
        run: |
          echo "Setting up validation environment"
          chmod +x automation-framework/**/*.sh
          
      - name: Syntax validation
        id: validate
        run: |
          echo "Validating shell scripts..."
          for script in automation-framework/**/*.sh; do
            if [[ -f "$script" ]]; then
              bash -n "$script" || exit 1
              echo "âœ“ $script"
            fi
          done
          echo "status=success" >> $GITHUB_OUTPUT
          
      - name: Check dependencies
        run: |
          echo "Checking required dependencies..."
          command -v jq >/dev/null 2>&1 || { echo "jq is required"; exit 1; }
          command -v curl >/dev/null 2>&1 || { echo "curl is required"; exit 1; }
          command -v python3 >/dev/null 2>&1 || { echo "python3 is required"; exit 1; }
          
      - name: Security scan
        run: |
          echo "Running security scan..."
          # Check for hardcoded credentials
          grep -r "password\|secret\|token\|key" automation-framework/ | grep -v "^#" | grep -v ".md:" || true
          
      - name: Upload validation report
        uses: actions/upload-artifact@v3
        with:
          name: validation-report
          path: |
            automation-framework/validation.log

  # Stage 2: Unit Tests
  unit-tests:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    needs: validate
    
    strategy:
      matrix:
        component: [daemon, monitoring, parallel, chaos]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install test dependencies
        run: |
          pip install pytest pytest-cov pytest-timeout psutil
          
      - name: Run component tests
        run: |
          echo "Testing ${{ matrix.component }} component..."
          
          # Create test script
          cat > test_${{ matrix.component }}.sh << 'EOF'
          #!/bin/bash
          set -e
          
          case "${{ matrix.component }}" in
            daemon)
              # Test daemon functionality
              ./automation-framework/daemon/workflow_daemon.sh start
              sleep 2
              ./automation-framework/daemon/workflow_daemon.sh status
              ./automation-framework/daemon/workflow_daemon.sh stop
              ;;
            monitoring)
              # Test metrics collector
              python3 -c "
          from automation-framework.monitoring.metrics_collector import MetricsCollector
          collector = MetricsCollector()
          collector.record_metric('test.metric', 42.0)
          metrics = collector.query_metrics('test.metric')
          assert len(metrics) > 0
          print('Metrics test passed')
              "
              ;;
            parallel)
              # Test parallel executor
              ./automation-framework/daemon/parallel_executor.sh add "echo test1" 1
              ./automation-framework/daemon/parallel_executor.sh add "echo test2" 2
              ./automation-framework/daemon/parallel_executor.sh start &
              sleep 5
              ./automation-framework/daemon/parallel_executor.sh stop
              ;;
            chaos)
              # Test chaos engineering
              ./automation-framework/chaos/chaos_test.sh validate
              ;;
          esac
          EOF
          
          chmod +x test_${{ matrix.component }}.sh
          ./test_${{ matrix.component }}.sh
          
      - name: Generate coverage report
        if: matrix.component == 'monitoring'
        run: |
          pytest --cov=automation-framework/monitoring --cov-report=xml
          
      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: test-results-${{ matrix.component }}
          path: |
            test-results/
            coverage.xml

  # Stage 3: Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup test environment
        run: |
          echo "Setting up integration test environment..."
          
          # Start all components
          ./automation-framework/daemon/workflow_daemon.sh start
          python3 automation-framework/monitoring/metrics_collector.py &
          ./automation-framework/daemon/parallel_executor.sh start
          
          sleep 5
          
      - name: Run integration scenarios
        run: |
          echo "Running integration test scenarios..."
          
          # Scenario 1: Workflow execution with monitoring
          ./automation-framework/daemon/workflow_daemon.sh execute "echo 'Integration test workflow'"
          
          # Scenario 2: Parallel task execution
          for i in {1..10}; do
            ./automation-framework/daemon/parallel_executor.sh add "sleep 1 && echo Task $i" 5
          done
          
          # Wait for completion
          sleep 15
          
          # Verify metrics collection
          curl -s http://localhost:8080/metrics | jq .
          
      - name: Performance benchmarks
        run: |
          echo "Running performance benchmarks..."
          
          # Benchmark parallel execution
          time ./automation-framework/daemon/parallel_executor.sh batch benchmark_tasks.txt
          
      - name: Cleanup
        run: |
          ./automation-framework/daemon/workflow_daemon.sh stop
          ./automation-framework/daemon/parallel_executor.sh stop
          pkill -f metrics_collector.py || true

  # Stage 4: Build Artifacts
  build:
    name: Build Artifacts
    runs-on: ubuntu-latest
    needs: integration-tests
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Create distribution package
        run: |
          echo "Creating distribution package..."
          
          # Create package directory
          mkdir -p dist/automation-framework-${{ env.FRAMEWORK_VERSION }}
          
          # Copy framework files
          cp -r automation-framework/* dist/automation-framework-${{ env.FRAMEWORK_VERSION }}/
          
          # Create installation script
          cat > dist/automation-framework-${{ env.FRAMEWORK_VERSION }}/install.sh << 'EOF'
          #!/bin/bash
          echo "Installing Automation Framework..."
          
          # Create installation directory
          INSTALL_DIR="${INSTALL_DIR:-/opt/automation-framework}"
          sudo mkdir -p "$INSTALL_DIR"
          
          # Copy files
          sudo cp -r * "$INSTALL_DIR/"
          
          # Set permissions
          sudo chmod +x "$INSTALL_DIR"/**/*.sh
          sudo chmod +x "$INSTALL_DIR"/**/*.py
          
          # Create symlinks
          sudo ln -sf "$INSTALL_DIR/daemon/workflow_daemon.sh" /usr/local/bin/workflow-daemon
          sudo ln -sf "$INSTALL_DIR/daemon/parallel_executor.sh" /usr/local/bin/parallel-executor
          
          echo "Installation complete!"
          EOF
          
          chmod +x dist/automation-framework-${{ env.FRAMEWORK_VERSION }}/install.sh
          
          # Create tarball
          cd dist
          tar -czf automation-framework-${{ env.FRAMEWORK_VERSION }}.tar.gz automation-framework-${{ env.FRAMEWORK_VERSION }}
          
      - name: Generate checksums
        run: |
          cd dist
          sha256sum automation-framework-${{ env.FRAMEWORK_VERSION }}.tar.gz > checksums.txt
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: automation-framework-${{ env.FRAMEWORK_VERSION }}
          path: |
            dist/*.tar.gz
            dist/checksums.txt

  # Stage 5: Deploy
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'staging' }}
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: automation-framework-${{ env.FRAMEWORK_VERSION }}
          path: dist/
          
      - name: Deploy to environment
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          echo "Deploying to $ENVIRONMENT environment..."
          
          # Environment-specific deployment
          case "$ENVIRONMENT" in
            development)
              echo "Deploying to development servers..."
              # rsync to dev servers
              ;;
            staging)
              echo "Deploying to staging servers..."
              # rsync to staging servers
              ;;
            production)
              echo "Deploying to production servers..."
              # Blue-green deployment for production
              ;;
          esac
          
      - name: Health check
        run: |
          echo "Running post-deployment health checks..."
          
          # Verify services are running
          # curl health endpoints
          
      - name: Notify deployment
        run: |
          echo "Deployment completed successfully!"
          # Send notification to Slack/Teams

  # Stage 6: Rollback (if needed)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    
    steps:
      - name: Initiate rollback
        run: |
          echo "Initiating rollback to previous version..."
          
          # Rollback logic here
          # - Restore previous version
          # - Restart services
          # - Verify rollback success
          
      - name: Notify rollback
        run: |
          echo "Rollback completed"
          # Send alert notification